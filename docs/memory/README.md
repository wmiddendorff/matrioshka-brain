# Memory System

The memory system provides persistent knowledge storage with hybrid search, combining vector similarity and keyword matching. Memories are stored locally in SQLite with embeddings generated by a local transformer model.

## Overview

- **Database**: `~/.matrioshka-brain/data/memory.db` (SQLite + sqlite-vec + FTS5)
- **Embeddings**: Local all-MiniLM-L6-v2 via `@xenova/transformers` (384 dimensions)
- **Search**: Hybrid (configurable weights, default 0.7 vector + 0.3 keyword), pure vector, or pure keyword
- **Deduplication**: SHA-256 content hash prevents duplicate entries
- **Access Logging**: Every retrieval is logged for analytics and pruning
- **Daily Logs**: Automatic daily markdown log files in `~/.matrioshka-brain/workspace/memory/`
- **File Indexing**: Auto-indexes `.md` files in the workspace directory

## Quick Start

Using MCP tools (via Claude Code):

```
# Add a memory
memory_add { content: "User prefers dark mode", entryType: "preference", importance: 7 }

# Search memories
memory_search { query: "UI preferences" }

# Get a specific memory by ID
memory_get { id: 1 }

# View statistics
memory_stats

# Delete a memory
memory_delete { id: 1 }
```

## Entry Types

| Type | Purpose | Example |
|------|---------|---------|
| `fact` | Objective information | "TypeScript is a superset of JavaScript" |
| `preference` | User preferences | "User prefers dark mode" |
| `event` | Things that happened | "Meeting with design team on Friday" |
| `insight` | Learned patterns | "FTS5 supports BM25 ranking" |
| `task` | Action items | "Project deadline is end of February" |
| `relationship` | Connections between things | "Alice manages the design team" |

## Entry Metadata

Each memory entry carries:

- **content**: The memory text (required)
- **entryType**: One of the six types above (default: `fact`)
- **source**: Where the memory came from (default: `manual`)
- **context**: Additional context about when/how it was learned
- **confidence**: 0.0 to 1.0 (default: 1.0)
- **importance**: 1 to 10 (default: 5)
- **tags**: Array of string tags for filtering
- **expiresAt**: Optional Unix timestamp for auto-expiration

## Search Modes

### Hybrid (default)
Combines vector similarity and keyword matching with configurable weights (default: 70% vector + 30% keyword). Weights can be adjusted via `config_set { path: "memory.hybridWeights.vector", value: 0.5 }`. Best for general-purpose queries where you want both semantic understanding and exact term matching.

### Vector
Pure semantic similarity search. Best when the query concept matters more than specific words. Example: searching "UI theme" will find "dark mode preference".

### Keyword
Pure FTS5 full-text search with BM25 scoring. Best when you need exact word matches. Searches content, context, and tags fields.

## Programmatic Usage

```typescript
import {
  getMemoryDb,
  addEntry,
  getEntry,
  deleteEntry,
  logAccess,
  getStats,
  generateEmbedding,
  ensureDailyLog,
  appendToDailyLog,
  startIndexer,
  stopIndexer,
} from 'matrioshka-brain';
import { hybridSearch } from 'matrioshka-brain';

// Add a memory
const db = getMemoryDb();
const embedding = await generateEmbedding('User prefers dark mode');
const result = addEntry(db, {
  content: 'User prefers dark mode',
  entryType: 'preference',
  importance: 7,
  tags: ['ui', 'theme'],
}, embedding);
// result: { id: 1, created: true, duplicate: false }

// Search
const results = await hybridSearch(db, {
  query: 'UI preferences',
  mode: 'hybrid',
  limit: 5,
});
// results: [{ entry: {...}, score: 0.85, matchedBy: ['vector', 'keyword'] }]

// Get stats
const stats = getStats(db);
// stats: { totalEntries: 1, byType: { preference: 1 }, ... }
```

## Daily Logs

When a new memory is added (via `memory_add`), a timestamped entry is automatically appended to `~/.matrioshka-brain/workspace/memory/YYYY-MM-DD.md`. This creates a chronological record of all memories added each day. Entries from the file auto-indexer (`source: 'file-index'`) are excluded to prevent feedback loops.

## File Auto-Indexing

When `memory.autoIndex` is enabled in config (default: `true`), the MCP server watches `~/.matrioshka-brain/workspace/` for `.md` file changes and automatically indexes their content into the memory database. Features:

- Uses `fs.watch` with recursive option (falls back to polling if unavailable)
- Content hash tracking to skip unchanged files
- 500ms debounce to handle rapid edits
- Skips files larger than 100KB
- Initial scan on startup indexes all existing `.md` files
- Indexed with `source: 'file-index'` and `entryType: 'fact'`

## Performance

- **Model load**: ~1.4s on first use (lazy-loaded, cached after)
- **Embedding generation**: ~4.7ms per entry
- **Vector search (10K entries)**: ~4ms P50, ~4ms P95
- **Keyword search (10K entries)**: ~1ms
- **Hybrid search (10K entries)**: ~4ms P50
- **Bulk insert (10K entries)**: ~412ms with fake embeddings
- **All searches under 500ms target** at 10,000 entries

## Security Considerations

- All data stored locally in `~/.matrioshka-brain/data/memory.db`
- Embeddings generated locally (no API calls, no data leaves the machine)
- No encryption at rest (SQLite file is readable)
- Content hash is SHA-256 (collision-resistant)

## See Also

- [API Documentation](./API.md)
- [Implementation Details](./IMPLEMENTATION.md)
- [Testing Strategy](./TESTING.md)
