# Product Requirements Document: Matrioshka Brain

**Version:** 1.1
**Date:** 2026-02-02
**Status:** Draft (Updated with Phase 1 refactoring plan and atlas-agent memory improvements)
**Author:** AI-assisted with user input

## Executive Summary

Matrioshka Brain is a **security-hardened autonomous AI agent** built as a **Claude Code skill**, designed to provide persistent memory, evolving personality, and controlled autonomous execution. The project extends Claude Code with Telegram integration, allowing bidirectional remote control while using your existing Claude subscription (not API). It runs side-by-side with the existing OpenClaw installation, offering a more secure architecture with approval-first execution model while maintaining compatibility with OpenClaw's file-based memory and identity concepts.

**Key Architectural Decision:** Matrioshka Brain is built as a Claude Code skill rather than a standalone agent, enabling use of your Claude.ai subscription instead of API tokens, while providing full remote control via Telegram.

## Vision Statement

Create a fully autonomous AI agent that learns and evolves through use, extending Claude Code with:
- **Persistent memory** that accumulates knowledge over time
- **Consistent identity** through the Soul/Identity separation framework
- **Controlled autonomy** via heartbeat and cron scheduling with security-first design
- **Multi-surface presence** starting with Telegram integration
- **Human-readable state** through file-based architecture

## Goals & Non-Goals

### Goals
1. **Security-first autonomy**: Enable autonomous execution without compromising user control or system safety
2. **Learning agent**: Build genuine knowledge accumulation through hybrid search memory system
3. **Persistent identity**: Implement evolving personality through Soul/Identity framework
4. **Extensible platform**: Create plugin architecture that extends Claude Code cleanly
5. **Multi-purpose utility**: Support personal assistant, development companion, research assistant, and general automation use cases

### Non-Goals
1. **Not a cloud service**: No multi-tenant SaaS deployment, single-user only
2. **Not replacing OpenClaw**: Runs side-by-side, no migration of existing OpenClaw data required
3. **Not feature parity**: Selective implementation of OpenClaw features with security focus
4. **Not modifying Claude Code core**: Plugin-based extension, no core code changes

## User Personas

### Primary: Power User / Developer
- Runs both OpenClaw and Matrioshka Brain
- Comfortable with command line and configuration files
- Values security, privacy, and transparency
- Wants autonomous assistance without losing control
- Uses agent across multiple contexts: coding, research, personal tasks

### Use Cases
1. **Personal Assistant**: Task management, reminders, information lookup, daily automation
2. **Development Companion**: Code review, testing, documentation, bug tracking
3. **Research Assistant**: Information gathering, synthesis, note-taking, knowledge management
4. **General Automation**: File operations, web scraping, data processing, scheduled tasks

## Product Overview

### Core Architecture

**Deployment Model:** Single-user local machine
**Extension Method:** Claude Code skill (loaded alongside Claude CLI)
**LLM Integration:** Uses existing Claude Code subscription (NOT Anthropic API)
**Security Model:** Approval-first (all autonomous actions require pre-approval or run read-only)
**Technology Stack:** TypeScript/Node.js
**Workspace Location:** `~/.matrioshka-brain/`

**Key Insight:** By building as a Claude Code skill, Matrioshka Brain uses your existing Claude subscription, stays ToS-compliant, and enables full bidirectional control via Telegram.

### System Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   You (via CLI or Telegram)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Claude Code CLI (Your Claude.ai Subscription)    â”‚
â”‚   Active session running "claude" command          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ Loads skill
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Matrioshka Brain Skill                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Memory    â”‚ â”‚   Soul/    â”‚ â”‚  Autonomy   â”‚    â”‚
â”‚  â”‚  System    â”‚ â”‚  Identity  â”‚ â”‚  Engine     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Telegram  â”‚ â”‚   Message  â”‚ â”‚  Approval   â”‚    â”‚
â”‚  â”‚  Bridge    â”‚ â”‚  Router    â”‚ â”‚  Manager    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚ Bidirectional
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram API (Remote Control Interface)           â”‚
â”‚  â€¢ Send messages/commands to Claude                â”‚
â”‚  â€¢ Receive Claude's responses                      â”‚
â”‚  â€¢ Give/deny approvals remotely                    â”‚
â”‚  â€¢ Issue commands (/status, /pause, etc)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Message Flow:
  Telegram â†’ Matrioshka Brain â†’ Claude Code â†’ Response â†’ Telegram
  Local CLI â†’ Claude Code â†’ Response â†’ Local CLI
  Approval â†’ Sent to BOTH Telegram AND CLI â†’ Approved from either
```

## Claude Code Skill Architecture

### Why a Skill?

**ToS Compliance:** Using the Anthropic API would cost per token. Building as a Claude Code skill allows use of your existing Claude.ai subscription while staying compliant with terms of service.

**How It Works:**
1. You run `claude` (normal Claude Code CLI)
2. Matrioshka Brain skill loads automatically in background
3. Telegram messages route through your active Claude session
4. Claude responds using your subscription
5. Responses route back to Telegram
6. You can interact from EITHER CLI or Telegram

### Skill Integration Points

**Loaded at startup:**
- Matrioshka Brain skill registers with Claude Code
- Telegram bot starts listening
- Memory system initializes
- Soul/Identity files loaded into context

**Message routing:**
- Incoming Telegram â†’ Appears in Claude session as user message
- Claude processes (you see it in your terminal)
- Response â†’ Routes back to Telegram user
- CLI messages â†’ Normal Claude Code behavior

**Bidirectional control:**
- Send commands via Telegram: `/status`, `/pause`, etc.
- Give approvals via Telegram when away from computer
- Everything logged and visible in CLI too

### Skill Capabilities

Unlike a standalone agent, the skill:
- âœ… Uses your Claude subscription (not API)
- âœ… Runs within Claude Code context
- âœ… Has access to Claude Code tools
- âœ… Can invoke other Claude Code skills
- âœ… Fully ToS compliant
- âœ… Transparent (you see all activity in your terminal)

## Phase 1: MVP Features

### 1. Memory Persistence System

**Objective:** Enable the agent to accumulate and recall knowledge across sessions.

**Note:** This section describes high-level requirements. See **Phase 3** for detailed implementation including the enhanced database schema with atlas-agent improvements (typed entries, deduplication, access logging).

#### Requirements

**Functional:**
- FR1.1: Store memories in human-readable markdown files
- FR1.2: Daily memory logs at `memory/YYYY-MM-DD.md`
- FR1.3: Curated long-term memory in `MEMORY.md`
- FR1.4: Hybrid search combining vector embeddings + keyword matching
- FR1.5: SQLite database with sqlite-vec extension for vector storage
- FR1.6: Full-text search (FTS5) for keyword queries
- FR1.7: Session transcript storage in JSONL format
- FR1.8: Auto-indexing on file changes (file watcher)
- FR1.9: Memory search tool accessible to agent during conversations
- FR1.10: **Typed memory entries** (fact, preference, event, insight, task, relationship)
- FR1.11: **Content hash deduplication** to prevent duplicate entries
- FR1.12: **Memory access logging** for analytics and pruning
- FR1.13: **Confidence and importance scores** on all entries
- FR1.14: **Optional expiration dates** for time-sensitive memories

**Non-Functional:**
- NFR1.1: Search results returned in <500ms for 95th percentile
- NFR1.2: Support up to 100,000 memory entries without degradation
- NFR1.3: Memory files remain human-readable and editable
- NFR1.4: Graceful degradation if vector search unavailable

#### Technical Specifications

**Storage:**
```
~/.matrioshka-brain/
â”œâ”€â”€ memory/
â”‚   â”œâ”€â”€ 2026-02-02.md          # Daily logs
â”‚   â”œâ”€â”€ 2026-02-03.md
â”‚   â””â”€â”€ ...
â”œâ”€â”€ MEMORY.md                   # Curated long-term
â”œâ”€â”€ tools/
â”‚   â””â”€â”€ manifest.md            # Tool documentation (atlas-agent pattern)
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ default/
â”‚       â”œâ”€â”€ sessions/
â”‚       â”‚   â”œâ”€â”€ main.jsonl      # Session transcripts
â”‚       â”‚   â””â”€â”€ ...
â”‚       â””â”€â”€ memory.db           # SQLite + embeddings
```

**Database Schema:** See Phase 3 for the enhanced schema with:
- `memory_entries` table with entry types, confidence, importance, expiration
- `memory_fts` virtual table for keyword search
- `daily_logs` table for aggregated summaries
- `memory_access_log` table for usage analytics
- Content hash column for deduplication

**Search API:**
```typescript
interface MemorySearchOptions {
  query: string;
  mode: 'hybrid' | 'vector' | 'keyword';
  limit?: number;
  threshold?: number;
  entryTypes?: ('fact' | 'preference' | 'event' | 'insight' | 'task' | 'relationship')[];
  minImportance?: number;  // 1-10
  minConfidence?: number;  // 0-1
}

interface MemoryResult {
  id: number;
  content: string;
  entryType: string;
  source: string;
  score: number;
  confidence: number;
  importance: number;
  timestamp: number;
  accessCount: number;
}

async function searchMemory(options: MemorySearchOptions): Promise<MemoryResult[]>
```

### 2. Soul & Identity System

**Objective:** Implement persistent, evolving agent personality through file-based configuration.

#### Requirements

**Functional:**
- FR2.1: Bootstrap files define agent personality and behavior
- FR2.2: `SOUL.md` contains core personality traits (agent can modify)
- FR2.3: `IDENTITY.md` contains concrete identifiers (name, type, avatar)
- FR2.4: `AGENTS.md` contains operating instructions and safety rules
- FR2.5: `USER.md` contains user profile information
- FR2.6: `BOOTSTRAP.md` for first-run initialization (auto-deleted)
- FR2.7: Files injected into Claude Code context at session start
- FR2.8: Agent can propose changes to SOUL.md, AGENTS.md (requires approval)
- FR2.9: Changes tracked with git-style diffs before approval

**Non-Functional:**
- NFR2.1: Bootstrap files loaded in <100ms
- NFR2.2: File changes reflected in next session automatically
- NFR2.3: Manual file edits supported and respected

#### File Templates

**SOUL.md Structure:**
```markdown
# Soul

## Core Essence
[Who you are at the deepest level]

## Communication Style
[How you express yourself]

## Boundaries
[What you will and won't do]

## Evolution
[How you've changed over time]
```

**IDENTITY.md Structure:**
```markdown
# Identity

- **Name**: [Agent name]
- **Type**: [AI assistant, companion, etc.]
- **Vibe**: [Core feeling/aesthetic]
- **Emoji**: [Signature emoji]
- **Avatar**: [Description or path]
```

**AGENTS.md Structure:**
```markdown
# Operating Instructions

## Memory Protocol
[How to use memory system]

## Safety Rules
[Security boundaries]

## Autonomous Behavior
[Guidelines for self-initiated actions]

## External vs Internal Actions
[When to interact with outside systems]
```

### 3. Basic Autonomy (Heartbeat)

**Objective:** Enable periodic self-initiated agent activity with security controls.

#### Requirements

**Functional:**
- FR3.1: Configurable heartbeat interval (default: 30 minutes)
- FR3.2: `HEARTBEAT.md` file contains task checklist
- FR3.3: Agent reads HEARTBEAT.md and executes pending tasks
- FR3.4: Support for `HEARTBEAT_OK` token to suppress empty responses
- FR3.5: Active hours configuration (timezone-aware)
- FR3.6: Pause/resume heartbeat via CLI command
- FR3.7: All heartbeat actions logged to audit trail
- FR3.8: Approval requirement for high-risk heartbeat actions
- FR3.9: Heartbeat only runs when main session idle

**Non-Functional:**
- NFR3.1: Heartbeat trigger accurate within Â±1 minute
- NFR3.2: Failed heartbeat doesn't crash system
- NFR3.3: Configurable retry logic with exponential backoff

#### Configuration

```typescript
interface HeartbeatConfig {
  enabled: boolean;
  interval: number;              // milliseconds
  activeHours?: {
    start: string;               // "09:00"
    end: string;                 // "23:00"
    timezone: string;            // "America/Los_Angeles"
  };
  requireApproval: boolean;      // approval-first mode
  maxActionsPerBeat: number;     // safety limit
}
```

**HEARTBEAT.md Format:**
```markdown
# Heartbeat Tasks

## Recurring
- [ ] Check for important notifications
- [ ] Update daily memory log if significant events

## One-time
- [ ] Research topic X (added 2026-02-02)
- [x] Completed task (done 2026-02-01)

---
HEARTBEAT_OK
```

### 4. Telegram Integration

**Objective:** Enable **bidirectional** remote interaction and control via Telegram - both sending messages to Claude AND receiving responses/notifications.

**Key Feature:** Telegram becomes a remote interface to your Claude Code session, allowing full control while away from your computer.

#### Requirements

**Functional:**
- FR4.1: Telegram bot based on grammY library
- FR4.2: DM pairing system (user must initiate with `/start`)
- FR4.3: **Bidirectional messaging:** Telegram â†” Claude Code â†” Telegram
- FR4.4: Route incoming Telegram messages to Claude Code session
- FR4.5: Route Claude Code responses back to Telegram user
- FR4.6: **Remote approvals:** Approval requests sent to Telegram, can approve remotely
- FR4.7: **Remote commands:** `/status`, `/pause`, `/resume` work from Telegram
- FR4.8: HTML formatting for rich message display
- FR4.9: Draft streaming support (real-time response updates)
- FR4.10: Heartbeat notifications sent to Telegram
- FR4.11: Configuration via environment variables (bot token)
- FR4.12: **Context awareness:** Claude knows when messages are from Telegram vs CLI

**Non-Functional:**
- NFR4.1: Message delivery within 2 seconds
- NFR4.2: Support long-polling (webhook optional)
- NFR4.3: Handle Telegram API rate limits gracefully
- NFR4.4: Secure token storage (not in git)

#### Security Requirements

**SR4.1:** Bot token stored in `~/.matrioshka-brain/secrets.env` (gitignored)
**SR4.2:** Only paired users can interact with bot
**SR4.3:** Pairing requires approval on local machine
**SR4.4:** All Telegram commands logged to audit trail
**SR4.5:** No sensitive information sent over Telegram without user approval

#### Bidirectional Flow Examples

**Scenario 1: Remote Chat**
```
[You on Telegram]: "What's on my calendar today?"
  â†“
[Routes to Claude Code session]
  â†“
[Claude processes using your subscription]
  â†“
[You on Telegram receive]: "You have 3 meetings: ..."
```

**Scenario 2: Remote Approval**
```
[Heartbeat triggers on your computer]
  â†“
[Needs approval to update memory]
  â†“
[You on Telegram receive]: "âš ï¸ APPROVAL: Update MEMORY.md? [APPROVE/DENY]"
  â†“
[You on Telegram]: "APPROVE"
  â†“
[Approval routes to Claude Code]
  â†“
[Action executes]
  â†“
[You on Telegram receive]: "âœ… Memory updated"
```

**Scenario 3: Remote Command**
```
[You on Telegram]: "/status"
  â†“
[Routes to Matrioshka Brain skill]
  â†“
[Skill queries system status]
  â†“
[You on Telegram receive]: "ğŸ“Š Status: Online, 3 tasks pending, uptime 4h"
```

#### API Design

```typescript
interface TelegramConfig {
  botToken: string;
  pairedUsers: number[];         // Telegram user IDs
  enableGroups: boolean;
  notifyHeartbeat: boolean;
}

class TelegramBridge {
  // Outgoing (to Telegram)
  async sendMessage(userId: number, text: string, options?: MessageOptions): Promise<void>
  async sendNotification(text: string): Promise<void>
  async requestApproval(userId: number, request: ApprovalRequest): Promise<boolean>

  // Incoming (from Telegram)
  async routeToClaudeCode(userId: number, message: string): Promise<void>
  async handleCommand(userId: number, command: string): Promise<void>

  // Pairing
  async pairUser(userId: number): Promise<boolean>  // requires local approval
  async unpairUser(userId: number): Promise<void>
}

// Integration with Claude Code
interface ClaudeCodeIntegration {
  async sendMessage(text: string, context: MessageContext): Promise<string>
  async onResponse(callback: (response: string, destination: string) => void): void
  async requestApproval(request: ApprovalRequest): Promise<boolean>
}
```

## Cross-Cutting Requirements

### Security & Privacy

**Approval System:**
- All file writes require approval (except memory logs)
- All external network requests require approval
- All command executions require approval
- Approval UI shows exact action with preview
- Approval decisions cached per session (optional)

**Audit Logging:**
- All tool executions logged with timestamp
- All file changes logged with diffs
- All autonomous actions logged with trigger
- Logs stored at `~/.matrioshka-brain/audit.log`
- Log rotation after 10MB or 30 days

**Sandboxing:**
- Memory database isolated from main filesystem
- Telegram bot runs in separate process
- File access restricted to `~/.matrioshka-brain/` by default
- Environment variables for secrets (never in code)

### Performance

- Memory search: <500ms p95
- Bootstrap file loading: <100ms
- Heartbeat trigger accuracy: Â±1 minute
- Telegram message delivery: <2 seconds

### Reliability

- Graceful degradation if components fail
- Retry logic with exponential backoff
- State recovery after crash
- Health check endpoint
- Process monitoring

### Observability

- Structured logging (JSON format)
- Log levels: debug, info, warn, error
- Metrics collection (optional, local only)
- Status dashboard (CLI command: `openclaw status`)

## User Interface

### CLI Commands

```bash
# Initialize new agent
openclaw init

# Start the agent (with heartbeat)
openclaw start

# Stop the agent
openclaw stop

# Status check
openclaw status

# Memory search
openclaw memory search "query"

# Memory add
openclaw memory add "content" [--source=file]

# Telegram pairing
openclaw telegram pair

# Configuration
openclaw config set heartbeat.interval 1800000
openclaw config get

# Audit log
openclaw audit [--tail] [--filter=tool:exec]
```

### Approval UI

Text-based approval prompts in terminal:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ APPROVAL REQUIRED                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tool: file_write                                 â”‚
â”‚ File: ~/.matrioshka-brain/SOUL.md                 â”‚
â”‚                                                  â”‚
â”‚ Diff:                                            â”‚
â”‚ - ## Boundaries                                  â”‚
â”‚ + ## Boundaries & Values                         â”‚
â”‚                                                  â”‚
â”‚ Reason: Updating soul to reflect new learning    â”‚
â”‚                                                  â”‚
â”‚ [A]pprove  [D]eny  [V]iew full  [R]emember      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Technical Architecture

### Plugin Structure

```
matrioshka-brain/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ plugin.ts              # Main plugin entry point
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â”œâ”€â”€ index.ts           # Memory system
â”‚   â”‚   â”œâ”€â”€ search.ts          # Hybrid search
â”‚   â”‚   â”œâ”€â”€ embeddings.ts      # Vector embeddings
â”‚   â”‚   â””â”€â”€ storage.ts         # SQLite + FTS
â”‚   â”œâ”€â”€ soul/
â”‚   â”‚   â”œâ”€â”€ index.ts           # Soul/Identity system
â”‚   â”‚   â”œâ”€â”€ bootstrap.ts       # File loader
â”‚   â”‚   â””â”€â”€ templates.ts       # Default templates
â”‚   â”œâ”€â”€ autonomy/
â”‚   â”‚   â”œâ”€â”€ heartbeat.ts       # Heartbeat engine
â”‚   â”‚   â”œâ”€â”€ scheduler.ts       # Future: cron
â”‚   â”‚   â””â”€â”€ executor.ts        # Action execution
â”‚   â”œâ”€â”€ telegram/
â”‚   â”‚   â”œâ”€â”€ bot.ts             # Telegram bot
â”‚   â”‚   â”œâ”€â”€ pairing.ts         # User pairing
â”‚   â”‚   â””â”€â”€ formatter.ts       # Message formatting
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ memory.ts          # Memory tools
â”‚   â”‚   â”œâ”€â”€ soul.ts            # Soul update tools
â”‚   â”‚   â””â”€â”€ telegram.ts        # Telegram tools
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ approval.ts        # Approval manager
â”‚   â”‚   â”œâ”€â”€ audit.ts           # Audit logging
â”‚   â”‚   â””â”€â”€ sandbox.ts         # Future: sandboxing
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ index.ts           # CLI commands
â”œâ”€â”€ templates/                 # Bootstrap file templates
â”œâ”€â”€ tests/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

### Plugin Integration with Claude Code

The plugin hooks into Claude Code at these extension points:

1. **Context Injection**: Bootstrap files loaded at session start
2. **Tool Registration**: Memory, soul, telegram tools added to tool registry
3. **Background Tasks**: Heartbeat scheduled via Claude Code task system
4. **Event Hooks**: File watch, session start/end, message received

### Data Flow: Memory Search

```
User Query
    â†“
Claude Code receives message
    â†“
Plugin injects memory search tool
    â†“
Agent decides to search memory
    â†“
memory_search(query: "previous discussion about X")
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Hybrid Search Engine        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Vector  â”‚   â”‚ Keyword  â”‚ â”‚
â”‚ â”‚ Search  â”‚   â”‚ Search   â”‚ â”‚
â”‚ â”‚ (HNSW)  â”‚   â”‚ (FTS5)   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â”‚
â”‚      â”‚             â”‚        â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚           â”Œâ”€â–¼â”€â”             â”‚
â”‚           â”‚ âŠ• â”‚ Combine     â”‚
â”‚           â””â”€â”¬â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
    Results ranked by relevance
              â†“
    Injected into context
              â†“
    Agent uses results to answer
```

### Data Flow: Autonomous Heartbeat

```
Timer triggers (every 30 min)
    â†“
Check active hours (if configured)
    â†“
Check if main session idle
    â†“
Load HEARTBEAT.md
    â†“
Parse uncompleted tasks
    â†“
Create agent turn in main session
    â†“
Agent processes tasks
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ For each action:            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚   â”‚ Requires         â”‚      â”‚
â”‚   â”‚ approval?        â”‚      â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚   Yes  â”‚  No                â”‚
â”‚   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚ Show    â”‚  â”‚ Execute â”‚ â”‚
â”‚   â”‚ prompt  â”‚  â”‚ directlyâ”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚
â”‚        â”‚            â”‚       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Log to audit trail     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Update HEARTBEAT.md (mark completed)
    â†“
Send notification to Telegram (if configured)
```

## Development Plan

**IMPORTANT EXECUTION NOTES:**
1. **Test-driven development**: Each phase must be fully tested with human-in-the-loop validation before moving to next phase
2. **Progress tracking**: Maintain PROGRESS.md file across all sessions to track completion status
3. **Iterative refinement**: Expect loose requirements to be refined during implementation
4. **No feature creep**: Do not proceed to next phase until current phase is proven working

### Phase 0: Project Setup & Foundation

**Objective:** Bootstrap TypeScript project with basic tooling and structure.

**Tasks:**
- Initialize TypeScript project with proper tsconfig
- Set up build tooling (esbuild or tsc)
- Configure testing framework (vitest)
- Create basic project structure (src/, tests/, templates/)
- Implement configuration system (JSON-based)
- Set up git repository with proper .gitignore

**Acceptance Criteria:**
- [ ] `npm run build` compiles TypeScript without errors
- [ ] `npm run test` runs test suite successfully
- [ ] Basic CLI entry point exists and runs (`openclaw --version`)
- [ ] Configuration can be loaded from `~/.matrioshka-brain/config.json`
- [ ] All secrets/tokens properly gitignored

**Testing:**
- Manual: Run build, run tests, execute CLI
- Unit tests: Configuration loading
- Human validation: Review project structure

**Estimated Time:** 1-2 sessions
**Blocker for:** All other phases

---

### Phase 1: Telegram Integration (PRIORITY)

**Objective:** Get basic Telegram bot working for remote testing and interaction.

**Rationale:** Enables remote testing while away from house, unlocks async development workflow.

**Tasks:**
- Install and configure grammY library
- Create basic bot that responds to messages
- Implement `/start` command for pairing
- Store bot token in `~/.matrioshka-brain/secrets.env`
- Local approval UI for pairing requests
- Message routing: Telegram â†’ local agent context
- Response routing: agent output â†’ Telegram
- Basic HTML formatting for messages
- `/status` command to check bot health

**Acceptance Criteria:**
- [ ] Bot comes online when `openclaw start` runs
- [ ] User can send `/start` to bot
- [ ] Pairing request appears in local terminal
- [ ] After approval, user is paired
- [ ] Messages sent to bot appear in local agent context
- [ ] Agent responses sent back to Telegram
- [ ] `/status` command returns bot uptime and paired users
- [ ] Bot gracefully handles rate limits
- [ ] Bot token is NOT in git repository

**Testing:**
- Manual: Send messages via Telegram, verify responses
- Integration: Full pairing flow from Telegram to local approval
- Edge cases: Invalid commands, rate limiting, bot restart
- Human validation: Use bot for 24 hours, verify stability

**Estimated Time:** 2-3 sessions
**Blocker for:** Heartbeat notifications, remote testing

---

#### Phase 1.5: Telegram Refactoring (Tool + Skill Hybrid)

**Objective:** Refactor Telegram integration from pure-skill to MCP tool + skill hybrid architecture for better separation of concerns.

**Rationale:** The initial Phase 1 implementation used file-based queues and a skill-only approach. This has limitations:
- Polling-based (messages sit in queue until skill invoked)
- No structured I/O (relies on parsing JSONL files manually)
- No automatic routing (Claude isn't notified when messages arrive)
- Context overhead (skill instructions loaded every invocation)

**Architecture Change:**

```
BEFORE (Pure Skill):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    JSONL files     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram Bot   â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚   Claude Code   â”‚
â”‚  (standalone)   â”‚  telegram-queue    â”‚   (skill only)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER (MCP Tool + Skill Hybrid):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Telegram Bot   â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   MCP Server    â”‚
â”‚  (standalone)   â”‚    direct calls    â”‚   (tools)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                â”‚
                                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                                       â”‚   Claude Code   â”‚
                                       â”‚ (tool + skill)  â”‚
                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Separation of Concerns:**
- **MCP Tool** = Capability (send/receive messages, structured I/O)
- **Skill** = Persona/workflow (what to do with messages, personality injection)
- **Hook** = Trigger (when to check for new messages)

**New Components:**

1. **MCP Server** (`~/.matrioshka-brain/mcp-server/`)
   ```typescript
   // Tool definitions with JSON schemas
   tools: [
     {
       name: "telegram_poll",
       description: "Get pending Telegram messages",
       inputSchema: {
         type: "object",
         properties: {
           limit: { type: "number", default: 10 },
           markRead: { type: "boolean", default: true }
         }
       },
       outputSchema: {
         type: "object",
         properties: {
           messages: {
             type: "array",
             items: {
               type: "object",
               properties: {
                 userId: { type: "number" },
                 username: { type: "string" },
                 text: { type: "string" },
                 timestamp: { type: "number" },
                 messageId: { type: "number" }
               }
             }
           }
         }
       }
     },
     {
       name: "telegram_send",
       description: "Send message to Telegram user",
       inputSchema: {
         type: "object",
         properties: {
           userId: { type: "number", required: true },
           text: { type: "string", required: true },
           parseMode: { type: "string", enum: ["HTML", "Markdown"], default: "HTML" }
         }
       }
     },
     {
       name: "telegram_pair",
       description: "Approve or deny a pairing request",
       inputSchema: {
         type: "object",
         properties: {
           userId: { type: "number", required: true },
           approve: { type: "boolean", required: true }
         }
       }
     },
     {
       name: "telegram_status",
       description: "Get Telegram bot status",
       outputSchema: {
         type: "object",
         properties: {
           online: { type: "boolean" },
           uptime: { type: "number" },
           pairedUsers: { type: "number" },
           pendingMessages: { type: "number" }
         }
       }
     }
   ]
   ```

2. **Claude Code Hook** (`~/.claude/hooks.json`)
   ```json
   {
     "user-prompt-submit": [
       {
         "command": "node ~/.matrioshka-brain/scripts/check-telegram.js",
         "condition": "always"
       }
     ]
   }
   ```

   The hook script outputs pending messages to inject into context:
   ```javascript
   // check-telegram.js
   const pending = getPendingMessages();
   if (pending.length > 0) {
     console.log(`\nğŸ“± [Telegram] ${pending.length} pending message(s):`);
     pending.forEach(m => console.log(`  @${m.username}: ${m.text}`));
   }
   ```

3. **Updated Skill** (streamlined, focuses on persona)
   ```markdown
   ---
   name: matrioshka-brain
   description: Matrioshka Brain autonomous companion
   allowed-tools: telegram_poll, telegram_send, telegram_pair, telegram_status, memory_search
   user-invocable: true
   ---

   # Matrioshka Brain ğŸ§ 

   When invoked, check for Telegram messages using the telegram_poll tool.
   Respond to users naturally and send responses via telegram_send tool.

   ## Personality
   Load from ~/.matrioshka-brain/SOUL.md and ~/.matrioshka-brain/IDENTITY.md

   ## Message Handling
   - Use telegram_poll to get pending messages
   - Process each message as a user request
   - Use telegram_send to reply
   ```

4. **Tool Manifest** (`~/.matrioshka-brain/tools/manifest.md`)
   ```markdown
   # Matrioshka Brain Tools

   | Tool | Purpose | Input | Output |
   |------|---------|-------|--------|
   | telegram_poll | Get pending messages | limit?, markRead? | messages[] |
   | telegram_send | Send message | userId, text, parseMode? | success |
   | telegram_pair | Handle pairing | userId, approve | success |
   | telegram_status | Bot status | - | status object |
   ```

**Refactoring Tasks:**
- [ ] Create MCP server skeleton with tool definitions
- [ ] Implement `telegram_poll` tool (read from queue, return structured data)
- [ ] Implement `telegram_send` tool (write to bot, return confirmation)
- [ ] Implement `telegram_pair` tool (approve/deny, update config)
- [ ] Implement `telegram_status` tool (query bot process)
- [ ] Create Claude Code hook for auto-checking messages
- [ ] Update skill to use tools instead of file parsing
- [ ] Create tools/manifest.md for discoverability
- [ ] Remove file-queue parsing from skill (tools handle it)
- [ ] Update standalone bot to expose HTTP API for MCP server
- [ ] Write integration tests for tool â†’ bot communication

**Acceptance Criteria (Phase 1.5):**
- [ ] MCP server registers tools with Claude Code
- [ ] `telegram_poll` returns structured message objects
- [ ] `telegram_send` delivers messages and returns confirmation
- [ ] Hook injects pending message count on session start
- [ ] Skill uses tools instead of file parsing
- [ ] Manifest accurately documents all tools
- [ ] Existing functionality preserved (no regression)

**Testing:**
- Unit tests: Each tool in isolation
- Integration: Tool â†’ Bot â†’ Telegram roundtrip
- Hook: Verify context injection works
- Skill: Verify tool invocation works
- Regression: All Phase 1 acceptance criteria still pass

**Estimated Time:** 1-2 sessions
**Blocker for:** Clean tool architecture for future phases

---

### Phase 2: Soul & Identity System

**Objective:** Implement persistent agent personality through bootstrap files.

**Tasks:**
- Create bootstrap file templates (SOUL.md, IDENTITY.md, AGENTS.md, USER.md)
- Implement first-run initialization flow (BOOTSTRAP.md)
- File loader that reads bootstrap files
- Context injection mechanism for Claude Code
- Soul update tool (agent can propose changes)
- Approval flow for soul/agents modifications
- Git-style diff display before approval
- Automatic reload on file changes

**Acceptance Criteria:**
- [ ] On first run, BOOTSTRAP.md guides user through setup
- [ ] All bootstrap files created in `~/.matrioshka-brain/`
- [ ] Files injected into agent context at session start
- [ ] Agent maintains consistent personality across sessions
- [ ] Agent can propose changes to SOUL.md (with approval)
- [ ] Manual file edits reflected in next session
- [ ] Diff shown before approving soul updates

**Testing:**
- Manual: First-run experience, personality consistency
- Unit tests: File loading, template rendering
- Integration: Edit SOUL.md manually, verify reload
- Human validation: Chat with agent over 3+ sessions, verify personality persists

**Estimated Time:** 2-3 sessions
**Blocker for:** Personality evolution, user profiling

---

### Phase 3: Memory Persistence System

**Objective:** Enable agent to accumulate and search knowledge across sessions.

**Improvements from atlas-agent:** This phase incorporates proven patterns from the atlas-agent project:
- Typed memory entries with metadata (confidence, importance, expiration)
- Content hash deduplication to prevent memory pollution
- Memory access logging for usage analytics and pruning
- Tool manifest for discoverability

**Tasks:**
- Set up SQLite database with enhanced schema (see below)
- Install and configure sqlite-vec extension
- Implement FTS5 virtual table for keyword search
- Embedding generation (choose provider: OpenAI or local)
- Hybrid search combining vector + keyword with configurable weights
- Memory indexing on startup
- File watcher for auto-indexing new memory files
- Daily memory log creation (`memory/YYYY-MM-DD.md`)
- Session transcript logging (JSONL format)
- Content hash deduplication on insert
- Memory access logging for analytics
- `memory_search` tool for agent
- `memory_add` tool with entry type support
- CLI: `openclaw memory search "query"`
- CLI: `openclaw memory add "content" --type=fact --importance=7`
- Create tools/manifest.md for memory tools

**Acceptance Criteria:**
- [ ] Memory database created at `~/.matrioshka-brain/agents/default/memory.db`
- [ ] Daily log auto-created when agent runs
- [ ] Session transcripts saved to JSONL
- [ ] `memory_search` tool returns relevant results with metadata
- [ ] Hybrid search works (both vector and keyword)
- [ ] Search results in <500ms for 1000+ entries
- [ ] File changes auto-indexed within 5 seconds
- [ ] Manual memory edits searchable immediately
- [ ] Duplicate content rejected via hash check
- [ ] Memory access logged for every search/retrieval
- [ ] Entry types (fact, preference, event, insight, task, relationship) supported
- [ ] Confidence and importance scores queryable

**Testing:**
- Unit tests: Search algorithm, embedding generation, database queries, deduplication
- Integration: Add memories, search, verify results, check access logs
- Performance: Load 10,000 entries, verify search speed
- Deduplication: Add same content twice, verify only one entry
- Human validation: Use agent for 1 week, verify memory recall accuracy

**Estimated Time:** 3-4 sessions
**Blocker for:** Learning capabilities, knowledge accumulation

---

#### Enhanced Memory Schema (atlas-agent improvements)

**Database Schema:**
```sql
-- Main memory entries table with typed entries and metadata
CREATE TABLE memory_entries (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  content TEXT NOT NULL,
  content_hash TEXT UNIQUE NOT NULL,    -- SHA-256 hash for deduplication
  entry_type TEXT NOT NULL DEFAULT 'fact',  -- fact, preference, event, insight, task, relationship
  source TEXT,                          -- file path, session ID, or 'manual'
  context TEXT,                         -- where/why this was learned
  confidence REAL DEFAULT 1.0,          -- 0.0 to 1.0
  importance INTEGER DEFAULT 5,         -- 1 to 10
  tags TEXT,                            -- JSON array of tags
  embedding BLOB,                       -- vector embedding (1536 dims for OpenAI)
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  expires_at INTEGER,                   -- optional expiration timestamp
  access_count INTEGER DEFAULT 0,       -- how often this memory is retrieved
  last_accessed_at INTEGER,
  metadata TEXT                         -- JSON for extensibility
);

-- Full-text search virtual table
CREATE VIRTUAL TABLE memory_fts USING fts5(
  content,
  context,
  tags,
  content='memory_entries',
  content_rowid='id'
);

-- Daily aggregated logs (human-readable summaries)
CREATE TABLE daily_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  date TEXT UNIQUE NOT NULL,            -- YYYY-MM-DD
  summary TEXT,
  key_events TEXT,                      -- JSON array
  created_at INTEGER NOT NULL
);

-- Memory access log for analytics and pruning decisions
CREATE TABLE memory_access_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  memory_id INTEGER NOT NULL,
  accessed_at INTEGER NOT NULL,
  access_type TEXT NOT NULL,            -- 'search', 'direct', 'context_injection'
  relevance_score REAL,                 -- how relevant it was to the query
  query_text TEXT,                      -- what query triggered this access
  FOREIGN KEY (memory_id) REFERENCES memory_entries(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_memory_type ON memory_entries(entry_type);
CREATE INDEX idx_memory_importance ON memory_entries(importance DESC);
CREATE INDEX idx_memory_expires ON memory_entries(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX idx_memory_hash ON memory_entries(content_hash);
CREATE INDEX idx_access_log_memory ON memory_access_log(memory_id);
CREATE INDEX idx_access_log_time ON memory_access_log(accessed_at DESC);
```

**Entry Types:**
| Type | Description | Example |
|------|-------------|---------|
| `fact` | Objective information | "User's favorite color is blue" |
| `preference` | User preferences | "Prefers concise responses" |
| `event` | Something that happened | "Deployed v2.0 on 2026-02-01" |
| `insight` | Learned patterns | "User tends to work late on Fridays" |
| `task` | Things to remember to do | "Follow up on PR review" |
| `relationship` | Connections between entities | "Project X depends on Library Y" |

**Memory Tool API:**
```typescript
// Enhanced memory_search tool
interface MemorySearchInput {
  query: string;
  mode?: 'hybrid' | 'vector' | 'keyword';  // default: 'hybrid'
  limit?: number;                           // default: 10
  threshold?: number;                       // minimum relevance score
  entryTypes?: EntryType[];                 // filter by type
  minImportance?: number;                   // filter by importance (1-10)
  minConfidence?: number;                   // filter by confidence (0-1)
  includeTags?: string[];                   // must have all these tags
  excludeExpired?: boolean;                 // default: true
}

interface MemorySearchResult {
  id: number;
  content: string;
  entryType: EntryType;
  score: number;                            // combined relevance score
  confidence: number;
  importance: number;
  source: string;
  tags: string[];
  createdAt: number;
  accessCount: number;
}

// Enhanced memory_add tool
interface MemoryAddInput {
  content: string;
  entryType?: EntryType;                    // default: 'fact'
  source?: string;                          // default: 'manual'
  context?: string;                         // why this is being stored
  confidence?: number;                      // default: 1.0
  importance?: number;                      // default: 5
  tags?: string[];
  expiresAt?: number;                       // optional expiration
}

interface MemoryAddResult {
  success: boolean;
  id?: number;
  duplicate?: boolean;                      // true if content already existed
  existingId?: number;                      // if duplicate, the existing entry ID
}
```

**Hybrid Search Algorithm:**
```typescript
// Configurable weights for hybrid search
interface HybridSearchConfig {
  vectorWeight: number;    // default: 0.7
  keywordWeight: number;   // default: 0.3
  importanceBoost: number; // default: 0.1 (multiply importance/10)
  recencyBoost: number;    // default: 0.05 (decay over time)
  accessBoost: number;     // default: 0.02 (frequently accessed = more relevant)
}

function hybridScore(
  vectorScore: number,
  keywordScore: number,
  entry: MemoryEntry,
  config: HybridSearchConfig
): number {
  const baseScore = (vectorScore * config.vectorWeight) +
                   (keywordScore * config.keywordWeight);

  const importanceBonus = (entry.importance / 10) * config.importanceBoost;

  const daysSinceCreation = (Date.now() - entry.createdAt) / (1000 * 60 * 60 * 24);
  const recencyBonus = Math.max(0, 1 - (daysSinceCreation / 365)) * config.recencyBoost;

  const accessBonus = Math.min(entry.accessCount / 100, 1) * config.accessBoost;

  return baseScore + importanceBonus + recencyBonus + accessBonus;
}
```

**Memory Tools Manifest** (`~/.matrioshka-brain/tools/manifest.md`):
```markdown
# Memory Tools

| Tool | Purpose | Key Inputs | Output |
|------|---------|------------|--------|
| memory_search | Search memories | query, mode?, entryTypes?, minImportance? | MemorySearchResult[] |
| memory_add | Add new memory | content, entryType?, importance?, tags? | { success, id, duplicate? } |
| memory_get | Get specific memory | id | MemoryEntry |
| memory_update | Update memory | id, updates | { success } |
| memory_delete | Delete memory | id | { success } |
| memory_stats | Get memory statistics | - | { totalEntries, byType, avgImportance, ... } |

## Entry Types

- `fact` - Objective information about the world or user
- `preference` - User preferences and settings
- `event` - Something that happened (timestamped)
- `insight` - Patterns or learnings derived from experience
- `task` - Things to remember or follow up on
- `relationship` - Connections between entities

## Search Modes

- `hybrid` (default) - Combines vector similarity + keyword matching
- `vector` - Pure semantic similarity search
- `keyword` - Pure BM25/FTS keyword search

## Best Practices

1. Always specify `entryType` when adding memories
2. Use `importance` 7-10 for critical information, 1-3 for minor details
3. Use `confidence` < 1.0 for uncertain or inferred information
4. Add `tags` for cross-cutting categories
5. Set `expiresAt` for time-sensitive information
```

---

### Phase 4: Basic Autonomy (Heartbeat)

**Objective:** Enable periodic self-initiated agent activity with security controls.

**Tasks:**
- Heartbeat scheduler with configurable interval
- HEARTBEAT.md parser (checkbox format)
- Task execution engine
- Approval manager for high-risk actions
- Audit logging system (`audit.log`)
- Active hours configuration (timezone-aware)
- CLI: `openclaw heartbeat pause/resume`
- CLI: `openclaw audit --tail`
- Telegram notification integration (from Phase 1)
- `HEARTBEAT_OK` token support

**Acceptance Criteria:**
- [ ] Heartbeat triggers every N minutes (configurable)
- [ ] Reads unchecked tasks from HEARTBEAT.md
- [ ] Executes tasks with approval for risky actions
- [ ] All actions logged to audit trail
- [ ] Respects active hours configuration
- [ ] Sends notifications to Telegram on completion
- [ ] Can pause/resume via CLI and Telegram
- [ ] No heartbeat when main session active
- [ ] Failed heartbeat doesn't crash system

**Testing:**
- Unit tests: Parser, scheduler, task executor
- Integration: Full heartbeat cycle with approvals
- Edge cases: System restart, clock changes, concurrent sessions
- Security: Verify all risky actions require approval
- Human validation: Run for 48 hours, verify reliability

**Estimated Time:** 3-4 sessions
**Blocker for:** Full autonomy, cron scheduling

---

### Phase 5: Security Hardening & Polish

**Objective:** Finalize security features and prepare for daily use.

**Tasks:**
- Approval UI polish (better formatting, colors)
- Secrets management audit (no tokens in git)
- Audit log viewer with filtering
- Security testing (penetration test)
- Documentation (README, setup guide)
- Error handling improvements
- Graceful shutdown handling
- Health check system
- Backup/restore functionality

**Acceptance Criteria:**
- [ ] All secrets properly isolated
- [ ] Approval UI is clear and user-friendly
- [ ] Audit log complete and searchable
- [ ] No security vulnerabilities in testing
- [ ] Documentation complete
- [ ] Error messages helpful
- [ ] System recovers from crashes
- [ ] Backups created automatically

**Testing:**
- Security audit: Review all approval points
- Penetration test: Attempt to bypass approvals
- Stress test: High message volume, rapid approvals
- Human validation: Use as primary agent for 1 week

**Estimated Time:** 2-3 sessions
**Blocker for:** Production use

---

### Future Phases (Post-MVP)

**Not in current scope, but roadmap:**
- Full cron scheduling (beyond heartbeat)
- Sandbox isolation (Docker containers)
- Tool orchestration layers
- Subagent spawning
- Web dashboard (optional UI)
- Additional messaging platforms (WhatsApp, Signal, etc.)
- Plugin SDK for community extensions
- Multi-agent support (separate identities)

## Success Metrics

### MVP Success Criteria

1. **Memory works**: Agent can recall information from previous sessions with >90% accuracy
2. **Identity persists**: Agent maintains consistent personality across sessions
3. **Heartbeat reliable**: Executes scheduled tasks within Â±1 minute, 99% uptime
4. **Telegram functional**: Messages delivered within 2 seconds, pairing works flawlessly
5. **Security effective**: Zero unapproved actions in testing, audit log complete
6. **User satisfaction**: Primary user (you) uses it daily for 1+ week

### Key Performance Indicators

- **Memory search latency**: <500ms p95
- **Heartbeat accuracy**: Â±1 minute
- **Telegram delivery time**: <2 seconds
- **Approval response time**: User decision within 30 seconds
- **System uptime**: >99% when running
- **Crash recovery**: Automatic restart within 1 minute

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|-----------|------------|
| Memory search too slow | High | Medium | Optimize indexing, use incremental updates, cache frequently accessed |
| Approval fatigue | High | High | Smart approval caching, risk-based auto-approval for low-risk actions |
| Heartbeat runaway | Critical | Low | Max actions per beat, kill switch, active hours enforcement |
| Telegram token leak | Critical | Medium | Secrets in gitignored file, env vars only, audit access |
| Plugin conflicts with Claude Code updates | Medium | Medium | Minimal core modifications, version pinning, compatibility testing |
| Memory corruption | High | Low | Database backups, WAL mode, fsync on write, integrity checks |

## Open Questions

1. **Embedding provider**: OpenAI, local model (sentence-transformers), or both?
2. **Backup strategy**: Automatic backups of memory database and bootstrap files?
3. **Multi-agent**: Support multiple agent identities in future phases?
4. **Sharing**: Export/import memory snapshots between users?
5. **Mobile**: iOS/Android app for Telegram alternative?

## Appendix

### Patterns Adopted from atlas-agent

The following patterns from the atlas-agent project (`/home/localadmin/Desktop/workspace/git/atlas-agent`) have been incorporated into Matrioshka Brain:

#### 1. Typed Memory Entries with Metadata

**Source:** atlas-agent `tools/memory/memory_db.py`

**What:** Memory entries have explicit types (fact, preference, event, insight, task, relationship) with metadata fields:
- `confidence` (0.0-1.0) - How certain we are about this information
- `importance` (1-10) - How critical this information is
- `expires_at` - Optional expiration for time-sensitive data
- `tags` - Cross-cutting categorization
- `context` - Where/why this was learned

**Why:** Enables smarter retrieval (prioritize high-importance, high-confidence memories), automatic pruning (remove low-value or expired entries), and better context injection.

#### 2. Content Hash Deduplication

**Source:** atlas-agent deduplication logic

**What:** SHA-256 hash of content stored in `content_hash` column with UNIQUE constraint. Before inserting, check if hash exists.

**Why:** Prevents memory pollution when the agent logs the same observation multiple times across sessions. Returns existing entry ID instead of creating duplicate.

#### 3. Memory Access Logging

**Source:** atlas-agent `memory_access_log` table

**What:** Every time a memory is retrieved (via search, direct access, or context injection), log:
- Which memory was accessed
- When it was accessed
- What type of access (search, direct, context)
- Relevance score for search results
- The query that triggered access

**Why:** Enables:
- Identifying frequently-used vs stale memories
- Reinforcement learning on memory importance
- Debugging why the agent "forgot" something (wasn't retrieved, not missing)
- Data-driven pruning decisions

#### 4. Tool Manifests

**Source:** atlas-agent `tools/manifest.md` and `goals/manifest.md`

**What:** Markdown files that serve as indices for available tools, documenting:
- Tool name and purpose
- Input parameters
- Output format
- Best practices

**Why:** Helps agents understand available tools without reading all source code. Enables validation that tool policies reference real tools. Keeps documentation synchronized with implementation.

#### 5. Hybrid Search with Configurable Weights

**Source:** atlas-agent `tools/memory/hybrid_search.py`

**What:** Combined BM25 (keyword) + vector (semantic) search with configurable weights:
```
score = (vector_score Ã— vector_weight) + (keyword_score Ã— keyword_weight) + bonuses
```

Bonuses for:
- High importance entries
- Recently created entries
- Frequently accessed entries

**Why:** Pure vector search misses exact matches; pure keyword search misses semantic similarity. Hybrid provides best of both. Weights allow tuning for different use cases.

### Glossary

- **Bootstrap files**: Configuration files that define agent personality and behavior
- **Soul**: Core personality essence that evolves over time
- **Identity**: Concrete metadata about the agent (name, avatar, etc.)
- **Heartbeat**: Periodic autonomous check-in by the agent
- **Memory**: Persistent knowledge storage with hybrid search
- **Approval-first**: Security model requiring user approval for actions
- **Hybrid search**: Combination of vector similarity and keyword matching

### References

- OpenClaw source code: `/home/localadmin/Desktop/workspace/openclaw`
- OpenClaw workspace: `/home/localadmin/clawd`
- Claude Code documentation: https://github.com/anthropics/claude-code
- grammY documentation: https://grammy.dev/
- sqlite-vec: https://github.com/asg017/sqlite-vec

### Version History

- **v1.1** (2026-02-02): Added Phase 1.5 refactoring plan (MCP tool + skill hybrid), integrated atlas-agent memory improvements (typed entries, deduplication, access logging, manifests)
- **v1.0** (2026-02-02): Initial PRD based on user requirements
