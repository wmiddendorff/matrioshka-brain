# Telegram Integration - Implementation Details

## Architecture

```
┌──────────────┐
│  MCP Tools   │  (src/tools/telegram.ts)
│  4 tools     │
└──────┬───────┘
       │  imports
       ▼
┌──────────────┐     ┌──────────────────────────────────────────────┐
│  IPC Client  │────►│  Bot Daemon (detached process)               │
│  (ipc.ts)    │ Unix│  ┌──────────────┐  ┌────────────────────┐   │
│              │◄────│  │ Socket Server │  │ grammY Bot         │   │
│  5s timeout  │ sock│  │ (net.Server)  │  │ /start, /help,     │   │
└──────────────┘     │  └──────────────┘  │ /status, msg handler│  │
                     │                     └────────────────────┘   │
                     │  ┌──────────────────────────────────┐        │
                     │  │ SQLite (data/telegram.db)         │        │
                     │  │ telegram_users | telegram_messages │        │
                     │  │ pending_approvals                 │        │
                     │  └──────────────────────────────────┘        │
                     └──────────────────────────────────────────────┘
```

## File Layout

```
src/telegram/
├── index.ts      # Module re-exports (checkConnection, getStatus, etc.)
├── types.ts      # Data interfaces (TelegramMessage, BotStatus, etc.)
├── protocol.ts   # IPC wire format (newline-delimited JSON)
├── daemon.ts     # Daemon lifecycle (start, stop, PID management)
├── ipc.ts        # Unix socket client with timeout
└── bot.ts        # Bot entry point (grammY + SQLite + socket server)

src/tools/
└── telegram.ts   # 4 MCP tool registrations
```

## Database Schema

All tables live in `~/.mudpuppy/data/telegram.db` with WAL journal mode.

### `telegram_users`

```sql
CREATE TABLE telegram_users (
  id INTEGER PRIMARY KEY,      -- Telegram user ID
  username TEXT,
  first_name TEXT,
  paired_at INTEGER NOT NULL,  -- Unix ms
  message_count INTEGER DEFAULT 0
);
```

### `telegram_messages`

```sql
CREATE TABLE telegram_messages (
  id TEXT PRIMARY KEY,              -- UUID generated by Mudpuppy
  user_id INTEGER NOT NULL,
  telegram_message_id INTEGER NOT NULL,
  chat_id INTEGER NOT NULL,
  text TEXT NOT NULL,
  timestamp INTEGER NOT NULL,       -- Unix ms
  read INTEGER DEFAULT 0            -- 0 = unread, 1 = read
);

CREATE INDEX idx_messages_user ON telegram_messages(user_id);
CREATE INDEX idx_messages_read ON telegram_messages(read);
```

### `pending_approvals`

```sql
CREATE TABLE pending_approvals (
  id TEXT PRIMARY KEY,          -- UUID
  user_id INTEGER NOT NULL,
  username TEXT,
  first_name TEXT,
  created_at INTEGER NOT NULL,  -- Unix ms
  status TEXT DEFAULT 'pending' -- 'pending' | 'approved' | 'denied'
);

CREATE INDEX idx_approvals_status ON pending_approvals(status);
```

Note: This is a separate approval table from the soul module's `data/approvals.db`. The Telegram daemon manages its own pairing approvals in the same database as messages for atomicity.

## Design Decisions

### Why a Separate Daemon Process?

The Telegram bot needs to long-poll the Telegram API continuously. MCP tools are request-response: they're invoked and return. A daemon solves this mismatch.

- **Daemon**: Always connected to Telegram, queues messages as they arrive
- **MCP tools**: Poll the queue when Claude wants to check messages
- **Alternative considered**: In-process polling thread. Rejected because the MCP server process lifecycle is controlled by Claude Code and may be restarted frequently.

### Why Unix Socket IPC Over HTTP?

- **No port conflicts**: Sockets use filesystem paths, not TCP ports
- **No network exposure**: Only accessible locally via filesystem permissions
- **Low overhead**: No HTTP framing, just newline-delimited JSON
- **Simple**: Node's `net` module handles it natively

### Why SQLite Over JSONL Queues?

The original plan used JSONL files for message queuing. SQLite was chosen instead because:

- **Concurrent access**: WAL mode handles daemon writes + tool reads safely
- **Indexed queries**: Filter by user, read status, etc. without scanning
- **Atomic operations**: Mark-as-read is a single UPDATE statement
- **Single file**: All Telegram state in one place
- **Message counts**: Tracked per-user with simple `UPDATE SET message_count = message_count + 1`

### Why Newline-Delimited JSON Over a Structured Protocol?

- **Simple to implement**: `JSON.stringify() + '\n'` and `line.split('\n')`
- **Debuggable**: Human-readable on the wire
- **Streaming-friendly**: Process complete lines as they arrive, buffer partials
- **No framing bugs**: Newline is the only delimiter needed

### Why grammY Over Telegraf?

- **Modern API**: Built for current Telegram Bot API features
- **TypeScript-first**: Strong typing out of the box
- **Active development**: More recent and actively maintained
- **Lightweight**: Smaller dependency tree

## IPC Protocol Details

### Wire Format

Each message is a single JSON object followed by `\n`. Multiple messages per connection are supported.

```
→ {"id":"abc-123","method":"status"}\n
← {"id":"abc-123","success":true,"result":{"running":true,...}}\n
```

### Request Correlation

Each request has a UUID `id`. The client matches responses by `id`, allowing (in theory) pipelining. In practice, the current client sends one request per connection.

### Connection Lifecycle

The IPC client creates a new socket connection for each request:

1. Connect to `~/.mudpuppy/bot/telegram.sock`
2. Send request as JSON line
3. Read response lines, match by request ID
4. Close connection

This is simpler than maintaining a persistent connection and handles daemon restarts gracefully.

### Timeout Handling

Default timeout is 5 seconds. If no matching response arrives, the client rejects with a timeout error and destroys the socket. The `ping` method uses a 2-second timeout.

## Daemon Lifecycle

### Starting (`startDaemon`)

1. Check if already running (PID file + process check)
2. Clean up stale socket file
3. Determine entry point:
   - Development: `npx tsx src/telegram/bot.ts`
   - Production: `node dist/telegram/bot.js`
4. Spawn detached child with `MUDPUPPY_DAEMON=1` env var
5. Wait for `DAEMON_READY` on stdout (10-second timeout)
6. Write PID file
7. Detach from parent (`child.unref()`)

### Stopping (`stopDaemon`)

1. Read PID from file
2. Check if process exists
3. Send SIGTERM
4. Wait up to 5 seconds for graceful shutdown
5. If still running, send SIGKILL
6. Remove PID file and socket file

### Graceful Shutdown (in daemon)

On SIGTERM or SIGINT:
1. Close socket server
2. Remove socket file
3. Remove PID file
4. Exit with code 0

## Bot Command Handlers

### `/start`

1. Check if user is already paired → reply "already paired"
2. Check for existing pending request → reply "pending"
3. Create new pairing request in `pending_approvals`
4. Reply with welcome message

### `/help`

Static HTML-formatted help message showing available commands.

### `/status`

1. If paired: show message count and paired date
2. If pending: show "pending approval"
3. If neither: prompt to use `/start`

### Text Messages

1. Check if sender is paired → if not, prompt to use `/start`
2. Generate UUID for message
3. Insert into `telegram_messages` with `read = 0`
4. Increment user's `message_count`

## Data Flow: Receiving a Message

```
1. User sends text on Telegram
2. grammY receives update via long polling
3. bot.on('message:text') handler fires
4. Check isPaired(userId) → reject if not
5. Create TelegramMessage with UUID
6. INSERT into telegram_messages (read=0)
7. UPDATE telegram_users SET message_count += 1
```

## Data Flow: Polling Messages

```
1. MCP tool telegram_poll invoked
2. Check isDaemonRunning() → error if not
3. IPC client connects to Unix socket
4. Send { method: "poll", params: { unreadOnly, limit, userId, markAsRead } }
5. Daemon queries telegram_messages with filters
6. If markAsRead: UPDATE SET read=1 for returned message IDs
7. Return messages array with user info joined
```

## Data Flow: Approving a Pairing

```
1. MCP tool telegram_pair { action: "approve", userId: 12345 }
2. IPC to daemon
3. Look up pending_approvals by userId
4. UPDATE pending_approvals SET status='approved'
5. INSERT OR REPLACE into telegram_users
6. Send Telegram notification to user
7. Return success message
```

## Error Handling

- **Daemon not running**: All MCP tools check `isDaemonRunning()` first and return a helpful hint
- **Socket not found**: IPC client checks file existence before connecting
- **IPC timeout**: 5-second default, returns error to MCP tool
- **Telegram API errors**: Caught in bot error handler, stored in `state.lastError`
- **Notification failures**: When approving/denying pairings, Telegram notification errors are silently ignored (the action still succeeds)
- **Invalid requests**: IPC returns error response with descriptive message

## Future Improvements

1. Group chat support with mention gating
2. HTML formatting validation before sending
3. Message pagination for large queues
4. Persistent connection pool for IPC (instead of connect-per-request)
5. Rate limiting per user
6. Message delivery confirmation tracking
7. Media message support (photos, documents)
